require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const axios = require('axios');

const app = express();
const PORT = process.env.PORT || 3000;

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'buildersdispatch',
  user: process.env.DB_USER || 'bduser',
  password: process.env.DB_PASSWORD,
  max: 20,
});

const CROSSMINT = {
  baseURL: process.env.CROSSMINT_BASE_URL,
  serverKey: process.env.CROSSMINT_SERVER_KEY,
  clientKey: process.env.CROSSMINT_CLIENT_KEY,
  projectId: process.env.CROSSMINT_PROJECT_ID,
  chainType: 'evm',
  chain: process.env.CROSSMINT_CHAIN || 'polygon-amoy',
};

const crossmint = axios.create({
  baseURL: CROSSMINT.baseURL,
  headers: { 'Content-Type': 'application/json', 'X-API-KEY': CROSSMINT.serverKey },
});

app.use(helmet());
app.use(compression());
app.use(cors({ origin: '*' }));
app.use(express.json());

const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
app.use('/api/', limiter);

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Authentication required' });
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
};

const requireAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') return res.status(403).json({ error: 'Admin access required' });
  next();
};

async function createWallet(email) {
  const response = await crossmint.post('/wallets', {
    chainType: 'evm',
    config: { adminSigner: { type: 'email', email } },
    owner: 'email:' + email,
  });
  return response.data;
}

app.get('/api/health', async (req, res) => {
  try {
    await pool.query('SELECT 1');
    res.json({ status: 'healthy', timestamp: new Date().toISOString(), database: 'connected', crossmint: CROSSMINT.projectId ? 'configured' : 'not configured' });
  } catch (error) {
    res.status(500).json({ status: 'unhealthy', error: error.message });
  }
});

app.get('/api/crossmint/config', (req, res) => {
  res.json({ clientKey: CROSSMINT.clientKey, projectId: CROSSMINT.projectId, chain: CROSSMINT.chain });
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
    
    const existing = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (existing.rows.length > 0) return res.status(409).json({ error: 'User already exists' });
    
    let walletData = null;
    try {
      walletData = await createWallet(email);
    } catch (e) {
      console.error('Wallet creation failed:', e.message);
    }
    
    const passwordHash = await bcrypt.hash(password, 12);
    const result = await pool.query(
      'INSERT INTO users (email, password_hash, first_name, last_name, crossmint_wallet_address) VALUES ($1, $2, $3, $4, $5) RETURNING id, email, first_name, last_name, crossmint_wallet_address',
      [email, passwordHash, firstName, lastName, walletData?.address]
    );
    
    const user = result.rows[0];
    const token = jwt.sign({ userId: user.id, email: user.email, role: 'customer' }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.status(201).json({ user, token, wallet: walletData });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await pool.query('SELECT id, email, password_hash, first_name, last_name, role, is_active FROM users WHERE email = $1', [email]);
    if (result.rows.length === 0) return res.status(401).json({ error: 'Invalid credentials' });
    
    const user = result.rows[0];
    if (!user.is_active) return res.status(403).json({ error: 'Account disabled' });
    
    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) return res.status(401).json({ error: 'Invalid credentials' });
    
    await pool.query('UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1', [user.id]);
    const token = jwt.sign({ userId: user.id, email: user.email, role: user.role }, process.env.JWT_SECRET, { expiresIn: '7d' });
    delete user.password_hash;
    res.json({ user, token });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

app.get('/api/products', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, name, slug, description, category, base_price, currency, image_url, warranty_years, installation_time_days, status FROM products WHERE is_active = true AND status = $1 ORDER BY created_at DESC', ['active']);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch products' });
  }
});

app.get('/api/products/:slug', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM products WHERE slug = $1 AND is_active = true', [req.params.slug]);
    if (result.rows.length === 0) return res.status(404).json({ error: 'Product not found' });
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch product' });
  }
});

app.post('/api/products', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { name, slug, description, category, basePrice, currency, imageUrl, warrantyYears, installationTimeDays } = req.body;
    const result = await pool.query(
      'INSERT INTO products (name, slug, description, category, base_price, currency, image_url, warranty_years, installation_time_days, created_by) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *',
      [name, slug, description, category, basePrice, currency, imageUrl, warrantyYears, installationTimeDays, req.user.userId]
    );
    res.status(201).json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create product' });
  }
});

app.post('/api/orders', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const { productId, installationAddress } = req.body;
    
    const productResult = await client.query('SELECT * FROM products WHERE id = $1 AND is_active = true', [productId]);
    if (productResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Product not found' });
    }
    const product = productResult.rows[0];
    
    const userResult = await client.query('SELECT * FROM users WHERE id = $1', [req.user.userId]);
    const user = userResult.rows[0];
    
    if (!user.crossmint_wallet_address) {
      try {
        const walletData = await createWallet(user.email);
        await client.query('UPDATE users SET crossmint_wallet_address = $1 WHERE id = $2', [walletData.address, user.id]);
      } catch (e) {
        console.error('Wallet creation during order:', e);
      }
    }
    
    const orderResult = await client.query(
      'INSERT INTO orders (customer_id, customer_email, product_id, product_snapshot, subtotal, total, currency, installation_address, status, payment_status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *',
      [user.id, user.email, product.id, JSON.stringify(product), product.base_price, product.base_price, product.currency, JSON.stringify(installationAddress), 'completed', 'paid']
    );
    
    await client.query('COMMIT');
    res.status(201).json({ 
      order: orderResult.rows[0],
      demo: true,
      message: 'Demo order created! In production, Crossmint checkout would process payment and mint NFT.'
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Order error:', error);
    res.status(500).json({ error: 'Failed to create order', details: error.message });
  } finally {
    client.release();
  }
});

app.get('/api/orders', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM orders WHERE customer_id = $1 ORDER BY created_at DESC', [req.user.userId]);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

app.listen(PORT, () => {
  console.log('BuildersDispatch API on port ' + PORT);
  console.log('Crossmint: ' + (CROSSMINT.projectId ? 'Configured' : 'Not configured'));
});
