require('dotenv').config();

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const axios = require('axios');

const app = express();
const PORT = process.env.PORT || 3000;

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'buildersdispatch',
  user: process.env.DB_USER || 'bduser',
  password: process.env.DB_PASSWORD,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

const CROSSMINT = {
  baseURL: process.env.CROSSMINT_BASE_URL,
  serverKey: process.env.CROSSMINT_SERVER_KEY,
  clientKey: process.env.CROSSMINT_CLIENT_KEY,
  projectId: process.env.CROSSMINT_PROJECT_ID,
  chainType: process.env.CROSSMINT_CHAIN_TYPE || 'evm',
  chain: process.env.CROSSMINT_CHAIN || 'polygon-amoy',
};

const crossmint = axios.create({
  baseURL: CROSSMINT.baseURL,
  headers: {
    'Content-Type': 'application/json',
    'X-API-KEY': CROSSMINT.serverKey,
  },
});

app.use(helmet());
app.use(compression());
app.use(cors({ origin: '*', credentials: true }));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });
app.use('/api/', limiter);

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Authentication required' });
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
};

const requireAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') {
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
};

async function createWallet(email) {
  try {
    const response = await crossmint.post('/wallets', {
      chainType: CROSSMINT.chainType,
      config: { adminSigner: { type: 'email', email: email } },
      owner: 'email:' + email,
    });
    return response.data;
  } catch (error) {
    console.error('Wallet error:', error.response?.data || error.message);
    throw error;
  }
}

app.get('/api/health', async (req, res) => {
  try {
    await pool.query('SELECT 1');
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: 'connected',
      crossmint: CROSSMINT.projectId ? 'configured' : 'not configured',
    });
  } catch (error) {
    res.status(500).json({ status: 'unhealthy', error: error.message });
  }
});

app.get('/api/crossmint/config', (req, res) => {
  res.json({
    clientKey: CROSSMINT.clientKey,
    projectId: CROSSMINT.projectId,
    chain: CROSSMINT.chain,
  });
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName } = req.body;
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }
    const existing = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (existing.rows.length > 0) {
      return res.status(409).json({ error: 'User already exists' });
    }
    let walletData = null;
    try {
      walletData = await createWallet(email);
    } catch (e) {
      console.error('Wallet creation failed:', e.message);
    }
    const passwordHash = await bcrypt.hash(password, 12);
    const result = await pool.query(
      'INSERT INTO users (email, password_hash, first_name, last_name, crossmint_wallet_address) VALUES ($1, $2, $3, $4, $5) RETURNING id, email, first_name, last_name, crossmint_wallet_address',
      [email, passwordHash, firstName, lastName, walletData?.address]
    );
    const user = result.rows[0];
    const token = jwt.sign(
      { userId: user.id, email: user.email, role: 'customer' },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    res.status(201).json({ user, token, wallet: walletData });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await pool.query(
      'SELECT id, email, password_hash, first_name, last_name, role, is_active FROM users WHERE email = $1',
      [email]
    );
    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const user = result.rows[0];
    if (!user.is_active) {
      return res.status(403).json({ error: 'Account disabled' });
    }
    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    await pool.query('UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1', [user.id]);
    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    delete user.password_hash;
    res.json({ user, token });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

app.get('/api/products', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, name, slug, description, category, base_price, currency, image_url, warranty_years, installation_time_days, status FROM products WHERE is_active = true AND status = $1 ORDER BY sort_order, created_at DESC',
      ['active']
    );
    res.json(result.rows);
  } catch (error) {
    console.error('Get products error:', error);
    res.status(500).json({ error: 'Failed to fetch products' });
  }
});

app.get('/api/products/:slug', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM products WHERE slug = $1 AND is_active = true',
      [req.params.slug]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Product not found' });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Get product error:', error);
    res.status(500).json({ error: 'Failed to fetch product' });
  }
});

app.post('/api/products', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { name, slug, description, category, basePrice, currency, imageUrl, warrantyYears, installationTimeDays } = req.body;
    const result = await pool.query(
      'INSERT INTO products (name, slug, description, category, base_price, currency, image_url, warranty_years, installation_time_days, created_by) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *',
      [name, slug, description, category, basePrice, currency, imageUrl, warrantyYears, installationTimeDays, req.user.userId]
    );
    res.status(201).json(result.rows[0]);
  } catch (error) {
    console.error('Create product error:', error);
    res.status(500).json({ error: 'Failed to create product' });
  }
});



app.get('/api/orders', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM orders WHERE customer_id = $1 ORDER BY created_at DESC', [req.user.userId]);
    res.json(result.rows);
  } catch (error) {
    console.error('Get orders error:', error);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

app.post('/api/webhooks/crossmint', async (req, res) => {
  try {
    const event = req.body;
    await pool.query('INSERT INTO webhook_events (event_type, provider, payload) VALUES ($1, $2, $3)', [event.type, 'crossmint', JSON.stringify(event)]);
    console.log('Crossmint webhook received:', event.type);
    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
});

app.listen(PORT, () => {
  console.log('BuildersDispatch API running on port ' + PORT);
  console.log('Environment: ' + (process.env.NODE_ENV || 'development'));
  console.log('Crossmint: ' + (CROSSMINT.projectId ? 'Configured' : 'Not configured'));
});

module.exports = app;


app.post('/api/orders', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const { productId, installationAddress } = req.body;
    
    const productResult = await client.query('SELECT * FROM products WHERE id = $1 AND is_active = true', [productId]);
    if (productResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Product not found' });
    }
    const product = productResult.rows[0];
    
    const userResult = await client.query('SELECT * FROM users WHERE id = $1', [req.user.userId]);
    const user = userResult.rows[0];
    
    if (!user.crossmint_wallet_address) {
      try {
        const walletData = await createWallet(user.email);
        await client.query('UPDATE users SET crossmint_wallet_address = $1 WHERE id = $2', [walletData.address, user.id]);
        user.crossmint_wallet_address = walletData.address;
      } catch (e) {
        console.error('Wallet creation failed:', e);
      }
    }
    
    const orderResult = await client.query(
      'INSERT INTO orders (customer_id, customer_email, customer_wallet_address, product_id, product_snapshot, subtotal, total, currency, installation_address, status, payment_status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING *',
      [user.id, user.email, user.crossmint_wallet_address, product.id, JSON.stringify(product), product.base_price, product.base_price, product.currency, JSON.stringify(installationAddress), 'demo_completed', 'demo_paid']
    );
    const order = orderResult.rows[0];
    
    await client.query('COMMIT');
    
    res.status(201).json({ 
      order,
      demo: true,
      message: 'Demo order created successfully. In production, Crossmint checkout would be initiated here.',
      nextSteps: [
        'Customer would pay via Crossmint',
        'Webhook confirms payment',
        'NFT warranty automatically mints',
        'Customer receives NFT via email'
      ]
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Create order error:', error);
    res.status(500).json({ error: 'Failed to create order', details: error.message });
  } finally {
    client.release();
  }
});
app.post('/api/orders', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const { productId, installationAddress } = req.body;
    
    const productResult = await client.query('SELECT * FROM products WHERE id = $1 AND is_active = true', [productId]);
    if (productResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Product not found' });
    }
    const product = productResult.rows[0];
    
    const userResult = await client.query('SELECT * FROM users WHERE id = $1', [req.user.userId]);
    const user = userResult.rows[0];
    
    if (!user.crossmint_wallet_address) {
      try {
        const walletData = await createWallet(user.email);
        await client.query('UPDATE users SET crossmint_wallet_address = $1 WHERE id = $2', [walletData.address, user.id]);
        user.crossmint_wallet_address = walletData.address;
      } catch (e) {
        console.error('Wallet creation failed:', e);
      }
    }
    
    const orderResult = await client.query(
      'INSERT INTO orders (customer_id, customer_email, customer_wallet_address, product_id, product_snapshot, subtotal, total, currency, installation_address, status, payment_status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING *',
      [user.id, user.email, user.crossmint_wallet_address, product.id, JSON.stringify(product), product.base_price, product.base_price, product.currency, JSON.stringify(installationAddress), 'demo_completed', 'demo_paid']
    );
    const order = orderResult.rows[0];
    
    await client.query('COMMIT');
    
    res.status(201).json({ 
      order,
      demo: true,
      message: 'Demo order created successfully. In production, Crossmint checkout would be initiated here.',
      nextSteps: [
        'Customer would pay via Crossmint',
        'Webhook confirms payment',
        'NFT warranty automatically mints',
        'Customer receives NFT via email'
      ]
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Create order error:', error);
    res.status(500).json({ error: 'Failed to create order', details: error.message });
  } finally {
    client.release();
  }
});
