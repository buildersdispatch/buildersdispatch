require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const axios = require('axios');

const app = express();
const PORT = process.env.PORT || 3000;

// Trust proxy for nginx
app.set('trust proxy', 1);

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'buildersdispatch',
  user: process.env.DB_USER || 'bduser',
  password: process.env.DB_PASSWORD,
  max: 20,
});

const CROSSMINT = {
  baseURL: process.env.CROSSMINT_BASE_URL,
  serverKey: process.env.CROSSMINT_SERVER_KEY,
  clientKey: process.env.CROSSMINT_CLIENT_KEY,
  projectId: process.env.CROSSMINT_PROJECT_ID,
  webhookSecret: process.env.CROSSMINT_WEBHOOK_SECRET,
  chainType: 'evm',
  chain: process.env.CROSSMINT_CHAIN || 'polygon-amoy',
};

const crossmint = axios.create({
  baseURL: CROSSMINT.baseURL,
  headers: { 
    'Content-Type': 'application/json', 
    'X-API-KEY': CROSSMINT.serverKey 
  },
});

app.use(helmet());
app.use(compression());
app.use(cors({ origin: '*', credentials: true }));
app.use(express.json());

const limiter = rateLimit({ 
  windowMs: 15 * 60 * 1000, 
  max: 100,
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api/', limiter);

// Auth middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Authentication required' });
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
};

const requireAdmin = (req, res, next) => {
  if (req.user.role !== 'admin') return res.status(403).json({ error: 'Admin access required' });
  next();
};

// Crossmint wallet creation
async function createWallet(email) {
  const response = await crossmint.post('/wallets', {
    chainType: 'evm',
    config: { adminSigner: { type: 'email', email } },
    owner: 'email:' + email,
  });
  return response.data;
}

// Health check
app.get('/api/health', async (req, res) => {
  try {
    await pool.query('SELECT 1');
    res.json({ 
      status: 'healthy', 
      timestamp: new Date().toISOString(), 
      database: 'connected', 
      crossmint: CROSSMINT.projectId ? 'configured' : 'not configured' 
    });
  } catch (error) {
    res.status(500).json({ status: 'unhealthy', error: error.message });
  }
});

// Crossmint config (public)
app.get('/api/crossmint/config', (req, res) => {
  res.json({ 
    clientKey: CROSSMINT.clientKey, 
    projectId: CROSSMINT.projectId, 
    chain: CROSSMINT.chain 
  });
});

// Register
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
    
    const existing = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (existing.rows.length > 0) return res.status(409).json({ error: 'User already exists' });
    
    let walletData = null;
    try {
      walletData = await createWallet(email);
    } catch (e) {
      console.error('Wallet creation failed:', e.message);
    }
    
    const passwordHash = await bcrypt.hash(password, 12);
    const result = await pool.query(
      'INSERT INTO users (email, password_hash, first_name, last_name, crossmint_wallet_address) VALUES ($1, $2, $3, $4, $5) RETURNING id, email, first_name, last_name, crossmint_wallet_address',
      [email, passwordHash, firstName, lastName, walletData?.address]
    );
    
    const user = result.rows[0];
    const token = jwt.sign({ userId: user.id, email: user.email, role: 'customer' }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.status(201).json({ user, token, wallet: walletData });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await pool.query('SELECT id, email, password_hash, first_name, last_name, role, is_active FROM users WHERE email = $1', [email]);
    if (result.rows.length === 0) return res.status(401).json({ error: 'Invalid credentials' });
    
    const user = result.rows[0];
    if (!user.is_active) return res.status(403).json({ error: 'Account disabled' });
    
    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) return res.status(401).json({ error: 'Invalid credentials' });
    
    await pool.query('UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1', [user.id]);
    const token = jwt.sign({ userId: user.id, email: user.email, role: user.role }, process.env.JWT_SECRET, { expiresIn: '7d' });
    delete user.password_hash;
    res.json({ user, token });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Get products
app.get('/api/products', async (req, res) => {
  try {
    const result = await pool.query('SELECT id, name, slug, description, category, base_price, currency, image_url, warranty_years, installation_time_days, status FROM products WHERE is_active = true AND status = $1 ORDER BY created_at DESC', ['active']);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch products' });
  }
});

// Get single product
app.get('/api/products/:slug', async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM products WHERE slug = $1 AND is_active = true', [req.params.slug]);
    if (result.rows.length === 0) return res.status(404).json({ error: 'Product not found' });
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch product' });
  }
});

// Create product (admin)
app.post('/api/products', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { name, slug, description, category, basePrice, currency, imageUrl, warrantyYears, installationTimeDays } = req.body;
    const result = await pool.query(
      'INSERT INTO products (name, slug, description, category, base_price, currency, image_url, warranty_years, installation_time_days, created_by) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *',
      [name, slug, description, category, basePrice, currency, imageUrl, warrantyYears, installationTimeDays, req.user.userId]
    );
    res.status(201).json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create product' });
  }
});

// CREATE ORDER - Full API Integration (No redirect!)
app.post('/api/orders', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const { productId, installationAddress, paymentMethod } = req.body;
    
    const productResult = await client.query('SELECT * FROM products WHERE id = $1 AND is_active = true', [productId]);
    if (productResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Product not found' });
    }
    const product = productResult.rows[0];
    
    const userResult = await client.query('SELECT * FROM users WHERE id = $1', [req.user.userId]);
    const user = userResult.rows[0];
    
    // Ensure user has wallet
    if (!user.crossmint_wallet_address) {
      try {
        const walletData = await createWallet(user.email);
        await client.query('UPDATE users SET crossmint_wallet_address = $1 WHERE id = $2', [walletData.address, user.id]);
        user.crossmint_wallet_address = walletData.address;
      } catch (e) {
        console.error('Wallet creation during order:', e);
      }
    }
    
    // Create order in database
    const orderResult = await client.query(
      'INSERT INTO orders (customer_id, customer_email, customer_wallet_address, product_id, product_snapshot, subtotal, total, currency, installation_address, status, payment_status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING *',
      [user.id, user.email, user.crossmint_wallet_address, product.id, JSON.stringify(product), product.base_price, product.base_price, product.currency, JSON.stringify(installationAddress), 'pending', 'pending']
    );
    const order = orderResult.rows[0];
    
    await client.query('COMMIT');
    
    // Return order info for frontend payment processing
    res.status(201).json({ 
      order,
      paymentRequired: {
        amount: parseFloat(order.total),
        currency: order.currency,
        recipient: user.email,
        orderId: order.id,
        orderNumber: order.order_number
      },
      message: 'Order created. Process payment via Crossmint API.'
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Order error:', error);
    res.status(500).json({ error: 'Failed to create order', details: error.message });
  } finally {
    client.release();
  }
});

// PROCESS PAYMENT - API Integration (called after order creation)
app.post('/api/orders/:orderId/payment', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const { orderId } = req.params;
    const { paymentMethod, paymentDetails } = req.body;
    
    const orderResult = await client.query('SELECT * FROM orders WHERE id = $1 AND customer_id = $2', [orderId, req.user.userId]);
    if (orderResult.rows.length === 0) {
      await client.query('ROLLBACK');
      return res.status(404).json({ error: 'Order not found' });
    }
    const order = orderResult.rows[0];
    
    // Update order status
    await client.query('UPDATE orders SET payment_status = $1, status = $2 WHERE id = $3', ['processing', 'payment_processing', orderId]);
    
    // In STAGING mode, simulate payment success
    // In PRODUCTION mode, this would call Crossmint payment API
    const paymentSuccess = true; // Simulate success for now
    
    if (paymentSuccess) {
      await client.query('UPDATE orders SET payment_status = $1, paid_at = CURRENT_TIMESTAMP, status = $2 WHERE id = $3', ['paid', 'paid', orderId]);
      
      // Mint NFT automatically
      try {
        const productSnapshot = order.product_snapshot;
        const nftMetadata = {
          name: `${productSnapshot.name} Warranty - Order #${order.order_number}`,
          description: `BuildersDispatch ${productSnapshot.name} with ${productSnapshot.warranty_years}-year transferable warranty certificate.`,
          image: productSnapshot.image_url || 'https://buildersdispatch.com/nft-default.png',
          attributes: [
            { trait_type: 'Product', value: productSnapshot.name },
            { trait_type: 'Order Number', value: order.order_number },
            { trait_type: 'Warranty Years', value: (productSnapshot.warranty_years || 5).toString() },
            { trait_type: 'Purchase Date', value: new Date().toISOString().split('T')[0] },
          ],
        };
        
        const nftResponse = await crossmint.post('/nfts/templates/default/tokens', {
          recipient: 'email:' + order.customer_email,
          metadata: nftMetadata,
        });
        
        await client.query(
          'UPDATE orders SET nft_minted = true, nft_token_id = $1, minted_at = CURRENT_TIMESTAMP, status = $2 WHERE id = $3',
          [nftResponse.data.id || 'minted', 'completed', orderId]
        );
        
        await client.query('COMMIT');
        
        res.json({ 
          success: true,
          order: { ...order, status: 'completed', payment_status: 'paid', nft_minted: true },
          nft: nftResponse.data,
          message: 'Payment successful! NFT warranty minted and sent to your email.'
        });
      } catch (nftError) {
        console.error('NFT minting failed:', nftError.response?.data || nftError.message);
        await client.query('UPDATE orders SET status = $1 WHERE id = $2', ['paid', orderId]);
        await client.query('COMMIT');
        
        res.json({ 
          success: true,
          order: { ...order, status: 'paid', payment_status: 'paid' },
          nftError: 'Payment successful but NFT minting pending. You will receive it shortly.',
          message: 'Payment successful! NFT warranty will be sent to your email shortly.'
        });
      }
    } else {
      await client.query('UPDATE orders SET payment_status = $1, status = $2 WHERE id = $3', ['failed', 'failed', orderId]);
      await client.query('COMMIT');
      res.status(402).json({ error: 'Payment failed' });
    }
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Payment error:', error);
    res.status(500).json({ error: 'Payment processing failed', details: error.message });
  } finally {
    client.release();
  }
});

// Get user orders
app.get('/api/orders', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query('SELECT * FROM orders WHERE customer_id = $1 ORDER BY created_at DESC', [req.user.userId]);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

// Webhook handler
app.post('/api/webhooks/crossmint', async (req, res) => {
  const client = await pool.connect();
  try {
    const event = req.body;
    console.log('Webhook received:', event.type, JSON.stringify(event));
    
    await client.query('BEGIN');
    await client.query(
      'INSERT INTO webhook_events (event_type, provider, payload) VALUES ($1, $2, $3)',
      [event.type, 'crossmint', JSON.stringify(event)]
    );
    await client.query('COMMIT');
    
    res.status(200).json({ received: true });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  } finally {
    client.release();
  }
});

app.listen(PORT, () => {
  console.log(`BuildersDispatch API on port ${PORT}`);
  console.log(`Crossmint: ${CROSSMINT.projectId ? 'Configured' : 'Not configured'}`);
});
